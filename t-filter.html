<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../t-input/t-input.html" />
<link rel="import" href="../t-button/t-button.html" />
<link rel="import" href="../t-range/t-range.html" />
<link rel="import" href="../t-starrating/t-starrating.html" />
<link rel="import" href="../iron-collapse/iron-collapse.html" />
<link rel="import" href="../t-checkbox/t-checkbox.html" />
<link rel="import" href="../t-calendar/t-calendar.html" />
<link rel="import" href="../t-header/t-header.html" />
<link rel="import" href="../paper-item/paper-item.html" />
<link rel="import" href="../iron-icon/iron-icon.html" />
<link rel="import" href="../iron-list/iron-list.html" />
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<!--
    `<t-filter>` is a polymer component that generates a playground for interacting with components.
    
    If parent view explicitly asks to show price or count with option filter by setting either of `show-{{group}}-count` or `show-{{group}}-price`,
    component handles this to show respective value along with `option` filter 

    <div class="demo-canvas">
    </div>

    <t-filter metadata-source="metadata url" property-source="property url" component="component name">

        
        <div class="component">
            'component template'
        </div>
    </t-filter>     
-->
<dom-module id="t-customfilter">
    <script type="text/javascript">
    Polymer({
        is: 't-customfilter',
        properties: {
            filterData: {
                type: Object,
                value: function() {
                    return {};
                }
            }
        },

        ready: function() {
            this.fire("t-customfilter-ready", {
                'filter': this.filterData
            });
        },

        // attached: function() {
        //     this.fire("t-customfilter-attached", {
        //         'filter': this.filterData
        //     });
        // },


    });
    </script>
</dom-module>
<dom-module id="t-filter">
    <style include="iron-flex-alignment"></style>
    <style include="iron-positioning"></style>
    <style include="iron-flex"></style>
    <style>
    :root {
        --checkbox-unchecked-color: var(-grey-two, #eeeeee);
        --checkbox-unchecked-ink-color: var(-grey-two, #eeeeee);
    }
    
    :host {
        font-size: var(--font-12, 12px);
        font-family: var(--primary-font-family);
        cursor: pointer;
        display: block;
        color: var(--primary-text-color, #333333);
        -webkit-tap-highlight-color: transparent;
    }
    
    .mainBody {
        height: 100vh;
    }
    
    .scrollsection > .item,
    .heading {
        padding: 10px;
    }
    
    #controller .category {
        padding: 2px 0;
        font-size: var(--font-16, 16px);
    }
    
    #controller .category,
    .chip {
        border-bottom: 1px solid;
        border-color: var(--grey-two, #eeeeee);
    }
    
    .category iron-icon {
        will-change: transform;
        transition: 0.3s ease transform;
    }
    
    .category.closed iron-icon {
        transform: rotate(180deg);
    }
    
    .filter-block {
        padding: 0 0 10px;
    }
    
    .filter-block > .layout {
        margin-top: 20px;
    }
    
    t-checkbox {
        width: 100%;
    }
    
    t-range {
        margin: 0 15px;
    }
    
    .range-block {
        padding: 10px 0;
    }
    
    .font-12 {
        font-size: var(--font-12, 12px);
    }
    
    t-starrating::content paper-icon-button {
        padding: 0;
        width: 16px;
        height: 16px;
        position: static;
        margin: 0;
        line-height: normal;
    }
    
    t-starrating::content .t-starrating-wrapper > span {
        width: auto;
        vertical-align: super;
        font-size: 0;
    }
    
    .modal {
        bottom: 0;
        z-index: 10;
        background: #fff;
    }
    
    #filteredRatio {
        padding: 10px;
        border-bottom: 1px solid;
        border-color: var(--grey-two, #eeeeee);
        position: relative;
        overflow: hidden;
        color: var(--grey-three, #bbbbbb);
    }
    
    .total-results {
        margin-left: 20px;
    }
    
    .icon-reset-search {
        margin-left: 10px;
    }
    /* patch to handle nexus page scroll */
    
    #controller {
        /* overflow: hidden; */
    }
    
    .scrollsection {
        /* overflow: auto; */
    }
    
    .link {
        color: var(--link-color, #0098ff);
    }
    
    .display-value {
        margin-right: 5px;
    }
    
    .devider {
        width: 1px;
        height: 20px;
        margin: 0px 5px 0 10px;
        background: var(--grey-three, #bbbbbb);
    }
    
    ::content #checkboxLabel {
        padding-left: 20px;
        line-height: 18px;
        color: var(--primary-text-color, #333333);
    }
    
    t-range {
        font-size: var(--font-14, 14px);
    }
    
    t-range::content .label,
    ::content .display-value,
    .secondary-text {
        color: var(--grey-three, #bbbbbb);
        font-size: var(--font-14, 14px);
    }
    /*new styling 
    
    .layout.item.style-scope.t-filter {
        float: left ;
        width: calc((100% - 120px) / 4) ;
        max-width: calc((100% - 120px) / 4) ;
        min-width: calc((100% - 120px) / 4) ;
        max-height: 280px;
        overflow-x: auto;
    }
    
    .secondary-text {
        display: none;
    }
    
    .category.noclick-header {
        pointer-events: none ;
    }
    
    .displayMobile {
        display: none ;
    }
    
    .filterApply {
        float: right ;
        margin-top: 220px;
    }
    
    @media (max-width: 800px) {
        .layout.item.style-scope.t-filter {
            width: calc((100% - 60px) / 3) ;
            max-width: calc((100% - 60px) / 3) ;
            max-height: 280px;
            min-height: 280px;
            overflow-x: auto;
        }
    }
    
    @media (max-width: 600px) {
        .layout.item.style-scope.t-filter {
            width: calc(100% - 20px) ;
            max-width: calc(100% - 20px) ;
            min-height: 0px;
            max-height: 100%;
        }
        .filterApply {
            float: right ;
            margin-top: 20px;
        }
        .secondary-text {
            display: block;
        }
        .category.noclick-header {
            pointer-events: auto ;
        }
        .displayMobile {
            display: block ;
        }
    }*/
    </style>
    <template>
        <div class="modal layout vertical" id="filterModal" hidden="{{hide}}">
            <div class="layout vertical mainBody">
                <div id="controller" class="layout vertical flex">
                    <div class="flex scrollsection">
                        <template is="dom-repeat" items="[[data]]" as="key">
                            <template is="dom-if" if="{{_isTypeMatching(key,'Options')}}">
                                <div class="layout item">
                                    <div class="category layout horizontal center noclick-header" data-category$="[[key.category]]" data-category$="[[key.category]]" on-click="_toggle">
                                        <div class="flex label">[[key.label]]</div>
                                        <iron-icon class="secondary-text" icon="icons:expand-less"></iron-icon>
                                    </div>
                                    <iron-collapse opened="[[!hideFilters]]" id="[[key.category]]" data-label$="[[key.label]]">
                                        <div class="filter-block">
                                            <template is="dom-if" if="[[_isNotRating(key.category)]]">
                                                <template is="dom-repeat" items="[[key.items]]" as="item">
                                                    <div class="layout horizontal" hidden$="[[_hideFilterByCount(item.additionalInfo)]]">
                                                        <div class="layout horizontal flex item-layout justified style-scope t-component-panel">
                                                            <t-checkbox data-label$="{{key.label}}" data-category$="[[key.category]]" data-type$="[[key.type]]" on-checked-change="_checkChanged" data-name$="[[item.name]]">
                                                                <div class="layout horizontal center justified">
                                                                    <div>[[item.label]]</div>
                                                                    <span class="display-value">[[_getDisplayValue(item)]]</span>
                                                                </div>
                                                            </t-checkbox>
                                                        </div>
                                                    </div>
                                                </template>
                                            </template>
                                            <template is="dom-if" if="[[_isRating(key.category)]]" as="key">
                                                <template is="dom-repeat" items="[[key.items]]" as="item">
                                                    <div class="layout item-layout justified style-scope t-component-panel">
                                                        <t-checkbox data-type$="[[key.type]]" data-label$="{{key.label}}" data-category$="[[key.category]]" name$="[[item.name]]" value$="[[item.value]]" on-checked-change="_checkChanged">
                                                            <div class="layout horizontal center font-12 justified">
                                                                <t-starrating disabled stars="5" rate="[[item.name]]"></t-starrating>
                                                                <div class="display-value">
                                                                    [[_getDisplayValue(item)]]
                                                                </div>
                                                            </div>
                                                        </t-checkbox>
                                                    </div>
                                                </template>
                                            </template>
                                        </div>
                                    </iron-collapse>
                                </div>
                            </template>
                            <template is="dom-if" if="{{_isTypeMatching(key,'Range')}}">
                                <div class="layout item">
                                    <div class="category layout horizontal center noclick-header" data-category$="[[key.category]]" on-click="_toggle">
                                        <div class="flex label">[[_getDisplayLabel(key)]]</div>
                                        <iron-icon class="secondary-text" icon="icons:expand-less"></iron-icon>
                                    </div>
                                    <iron-collapse opened="[[!hideFilters]]" id="Iron-collapse1">
                                        <div class="filter-block">
                                            <template is="dom-repeat" items="[[key.items]]" as="range" index-as="i">
                                                <template is="dom-if" if="[[_isEven(i)]]">
                                                    <div class="range-block">
                                                        <t-range label="[[range.label]]" data-index$="[[i]]" data-category$="[[key.category]]" data-type$="[[key.type]]" data-group$="[[range.group]]" min="[[_getMinRange(key.items, i)]]" max="[[_getMaxRange(key.items, i)]]" on-range-change="_rangeChanged" margin="1"></t-range>
                                                    </div>
                                                </template>
                                            </template>
                                        </div>
                                    </iron-collapse>
                                </div>
                            </template>
                            <template is="dom-if" if="{{_isTypeMatching(key,'DateRange')}}">
                                <div class="layout item">
                                    <div class="category layout horizontal center noclick-header" data-category$="[[key.category]]" on-click="_toggle">
                                        <div class="flex label">[[_getDisplayLabel(key)]]</div>
                                        <iron-icon class="secondary-text" icon="icons:expand-less"></iron-icon>
                                    </div>
                                    <iron-collapse opened="[[!hideFilters]]" id="Iron-collapse2">
                                        <div class="filter-block">
                                            <template is="dom-repeat" items="[[key.items]]" as="dateRange" index-as="i">
                                                <template is="dom-if" if="[[_isEven(i)]]">
                                                    <div class="layout horizontal">
                                                        <t-calendar class="flex margin-horizontal" data-index="0" data-category$="[[key.category]]" data-type$="[[key.type]]" data-group$="[[dateRange.group]]" label="Start Date" name="StartDate" id="startDate" selected-date="{{startDate}}" format="mm/dd/yyyy" on-selected-date-changed="_dateChanged" min="[[minStartDate]]">
                                                        </t-calendar>
                                                        &nbsp; &nbsp; &nbsp;
                                                        <t-calendar class="flex" data-index="1" data-category$="[[key.category]]" data-type$="[[key.type]]" data-group$="[[dateRange.group]]" label="End Date" name="EndDate" id="endDate" selected-date="{{endDate}}" format="mm/dd/yyyy" on-selected-date-changed="_dateChanged" min="[[minEndDate]]">
                                                        </t-calendar>
                                                    </div>
                                                </template>
                                            </template>
                                        </div>
                                    </iron-collapse>
                                </div>
                            </template>
                            <template is="dom-if" if="{{!_isFilterTypeSupported(key)}}">
                                <div class="layout item">
                                    <div class="category layout horizontal center noclick-header" data-category$="[[key.category]]" on-click="_toggle">
                                        <div class="flex label">[[_getDisplayLabel(key)]]</div>
                                        <iron-icon class="secondary-text" icon="icons:expand-less"></iron-icon>
                                    </div>
                                    <iron-collapse opened="[[!hideFilters]]" id="Iron-collapse2">
                                        <div class="filter-block">
                                            <t-customfilter filter-data="{{key}}" on-t-customfilter-ready="_runCustomHashReady"></t-customfilter>
                                        </div>
                                    </iron-collapse>
                                </div>
                            </template>
                        </template>
                        <!--- filter apply and cancel button -->
                        <div class="heading layout item filterApply">
                            <div class="layout horizontal center justified item-layout">
                                <a class="link" on-click="_resetFilters">Reset</a>
                                <t-button id="applyfilters" label="Apply" class="primary" on-click="_applyFilters" disabled="true"></t-button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </template>
</dom-module>
<script>
/*
Sample custom filter api
 */
var api = {
    category: '',
    type: '',
    element: null,

    addHtml: function(customFilterElem, filterData, onChangeCallback) {

    },

    resetElement: function(customFilterElem) {

    },

    getDisplayLabel: function(filterData) {

    },

    getAppliedFilter: function(customFilterElem, filterData, lastChange) {

    }
};

Polymer({

    is: 't-filter',

    properties: {


        data: {
            type: Array,
            value: function() {
                return [];
            }
        },

        includeFilters: {
            type: Array,
            value: function() {
                return [];
            }
        },

        appliedFilters: {
            type: Array,
            value: function() {
                return [];
            },
            readOnly: true,
        },

        hide: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
        },

        customFiltersHash: {
            type: Array,
            value: function() {
                return [];
            }
        },

        _cachedFilters: {
            type: Array,
            value: function() {
                return [];
            }
        },



        /*
        TODO: Remove all below ones and expose extension for all in-built filters
         */
        _currency: {
            type: String,
            value: 'USD'
        },

        _disableFilters: {
            type: Boolean,
            value: false
        },

        hideFilters: {
            type: Boolean,
            value: false
        },

        minStartDate: {
            type: Boolean,
            value: false
        },

        minEndDate: {
            type: Boolean,
            value: false
        }
    },

    observers: [
        '_filtersAddedOrRemoved(data.splices)'
    ],

    ready: function() {
        //debugger;
    },

    attached: function() {
        //debugger;
    },

    /*
    Filter core
     */
    _filtersAddedOrRemoved: function(e) {
        if (this.data) {
            this.data = this._applyInclusions(this.data);

            var $this = this;
            this.async(function() {
                $this.data.forEach(function(fItem) {
                    if (['options', 'rating'].indexOf(fItem.type.toLowerCase()) != -1 ) {
                        if (fItem.items) {
                            var isAllPresent = false;
                            fItem.items.forEach(function(oItem) {                                
                                if (oItem.additionalInfo && isAllPresent == false) {
                                    oItem.additionalInfo.forEach(function(aItem) {
                                        if (aItem.key && aItem.key.toLowerCase() == 'isall' &&
                                            aItem.value && aItem.value.toLowerCase() == 'true') {
                                            
                                            var cbk = Polymer.dom($this.root).querySelector('[data-name="' + oItem.name + '"][data-category="' + fItem.category + '"][data-type="' + fItem.type + '"]');
                                            if (cbk) {
                                                cbk.checked = true;   //TODO: Should check API response whether to select element or not
                                                isAllPresent = true;                                                
                                            }
                                        }
                                    })
                                }
                            })
                        }

                    }
                });
            }, 350); //delay to render html
        }
    },

    _applyInclusions: function(filters) {
        var component = this;
        if (!this.includeFilters || this.includeFilters.length == 0)
            return filters;

        var inclusiveFilters = filters.filter(function(group) {
            if (component.includeFilters.indexOf(group.category) >= 0)
                return true;
            return false;
        });
        return inclusiveFilters;
    },

    _isTypeMatching: function(key, type) {
        if (key.type === type && key.items.length > 0)
            return true;
        return false;
    },

    _isFilterTypeSupported: function(key) {
        if (key.type && ['options', 'range', 'daterange'].indexOf(key.type.toLowerCase()) != -1) {
            return true;
        }
        return false;
    },

    _toggle: function(event) {
        event.currentTarget.classList.toggle('closed');
        var parentElement = event.currentTarget.parentElement,
            element = parentElement.querySelector('iron-collapse');
        if (element !== null)
            element.toggle();
        event.stopPropagation();
        return false;
    },

    _resetElement: function(element, name, category) {
        var cHash = this._getCustomHash(category, name);
        if (cHash) {
            cHash.resetElement(cHash.filterElem);
        } else {
            switch (element.tagName.toLowerCase()) {
                case 't-checkbox':
                    element.checked = false;
                    break;
                case 't-range':
                    if (name.toLowerCase() == 'range') {
                        element.from = element.min.toString();
                        element.to = element.max.toString();
                    }

                    break;
                case 't-input':
                    element.value = '';
                    break;
                case 't-calendar':
                    element._clear();
                    //patch because in app is not removing the input value
                    element.querySelector('input').value = '';
                    break;
            }
        }
    },

    _resetFilters: function() {
        var component = this;
        this._cachedFilters.forEach(function(cache) {
            component._resetElement(cache.element, cache.type, cache.category);
        });
        this._cachedFilters = this._cachedFilters.filter(function(filter, index) {
            return false;
        });
        setTimeout(function() {
            component._applyFilters();
        }, 0);
    },

    _getDisplayLabel: function(key) {
        var cHash = this._getCustomHash(key.category, key.type);
        if (cHash) {
            return cHash.getDisplayLabel(key);
        } else {
            if (key.items[0].additionalInfo && key.items[0].additionalInfo[0].value.toLowerCase() !== 'ticks') {
                if (this._currency) {
                    return key.label + ' (' + this._currency + ')';
                }
                return key.label + ' (' + key.items[0].additionalInfo[0].value + ')';
            }
            return key.label;
        }
    },

    _applyFilters: function(e) {
        if (e) {
            if (e.target.id == 'applyfilters' && e.target.disabled) {
                return;
            }
        }
        this.$.applyfilters.disabled = true;
        var component = this;
        var filters = [];
        this._cachedFilters.forEach(function(filter) {
            filters = filters.concat(component._getAppliedFilter(filter));
        });
        this._setAppliedFilters(filters);
        setTimeout(function() {
            component.fire('filter-change', {
                "filters": component.appliedFilters,
                "count": component._cachedFilters.length
            });
        }, 0);
    },

    _getAppliedFilter: function(filter) {
        var filters = [];
        switch (filter.type) {
            case 'Options':
                filters.push({
                    "category": filter.category,
                    "group": filter.group,
                    "name": filter.name,
                    "value": filter.value,
                    "label": filter.label,
                    "type": filter.type
                });
                break;
            case 'Range':
                filters.push({
                    "category": filter.category,
                    "group": filter.group,
                    "name": "Min",
                    "value": filter.min,
                    "label": filter.label,
                    "type": filter.type
                });
                filters.push({
                    "category": filter.category,
                    "group": filter.group,
                    "name": "Max",
                    "value": filter.max,
                    "label": filter.label,
                    "type": filter.type
                });
                break;
            case 'DateRange':
                filters.push({
                    "category": filter.category,
                    "group": filter.group,
                    "name": filter.name,
                    "value": filter.element.selectedDate,
                    "label": filter.label,
                    "type": filter.type
                });
                break;
            default:
                var cHash = this._getCustomHash(filter.category, filter.type);
                var lastChange = this._cachedFilters.find(function(data) {
                    return data.category == filter.category && data.type == filter.type;
                });
                if (cHash) {
                    var data = cHash.getAppliedFilter(cHash.filterElem, filter, lastChange);
                    if (data) {
                        if (Array.isArray(data)) {
                            filters = filters.concat(data)
                        } else {
                            filters.push(data);
                        }
                    }
                }
        }

        return filters;
    },

    _getCountValue: function(items) {
        if (!items || !items.length)
            return '';

        var count = '';
        items.forEach(function(data) {
            if (data.key && data.key == 'Count') {
                count = '(' + data.value + ')';
            }
        });

        return count;
    },

    /**
     * This method returns diplay value for a filter.
     * It might be either `count` in additional info or `price` in the item value with _currency.
     * If parent view explicitely asks to show price or count by setting either of `show-{{group}}-count` or `show-{{group}}-price`,
     * method shows that value.
     * @param  {[Object]} item {"group":"Price","name":"Min","label":"Minimum Price","displayValue":"$17.49","value":"17.49","selectedValue":null,"additionalInfo":[{"key":"Unit","value":"$"}]}
     * @return {String}
     */
    _getDisplayValue: function(item) {
        var showCountProp = 'show' + item.group + 'Count';
        var showPriceProp = 'show' + item.group + 'Price';
        if (!this[showPriceProp] && !this[showCountProp]) {
            if (parseFloat(item.value)) {
                return this._getMinValueWithCurrency(item);
            } else {
                return this._getCountValue(item.additionalInfo);
            }
        } else if (this[showPriceProp]) {
            return this._getMinValueWithCurrency(item);
        } else if (this[showCountProp]) {
            return this._getCountValue(item.additionalInfo);
        }
        return "";
    },

    _getMinValueWithCurrency: function(item) {
        if (this._currency) {
            item.value = parseFloat(Math.round(item.value * 100) / 100);
            return this._currency + ' ' + item.value;
        } else {
            return item.displayValue;
        }
    },

    _getCustomHash: function(category, type) {
        if (this.customFiltersHash && this.customFiltersHash.length && category && type) {
            var cFilter = this.customFiltersHash.find(function(data) {
                return data.category == category && data.type == type
            });
            return cFilter;
        }
    },

    _runCustomHashReady: function(e) {
        var component = this
        var cHash = this._getCustomHash(e.detail.filter.category, e.detail.filter.type);
        if (cHash) {
            cHash.filterElem = e.srcElement; //back field
            cHash.addHtml(e.srcElement, e.detail.filter, function(changeData) {

                component.$.applyfilters.disabled = false;

                component._cachedFilters = component._cachedFilters.filter(function(filter) {
                    if (filter.category === changeData.category && filter.name === changeData.name)
                        return false;
                    return true;
                });
                component._cachedFilters.push(changeData);
            });
        }
    },


    /*
    Option filter stuff
     */
    _hideFilterByCount: function(items) {
        if (!items || !items.length)
            return false;

        var hideFilter = false;
        items.forEach(function(data) {
            if (data.key && data.key == 'Count' && data.value == 0) {
                hideFilter = true;
            }
        });

        return hideFilter;
    },

    _checkChanged: function(e) {
        var instance = e.model.item;
        var target = e.currentTarget;
        var category = target.getAttribute("data-category");

        if (instance) {
            this.$.applyfilters.disabled = false;

            var label = e.currentTarget.getAttribute("data-label");
            var type = e.currentTarget.getAttribute("data-type");
            var currentFilter = {
                "category": category,
                "group": instance.group,
                "name": instance.name,
                "value": instance.value,
                "label": label,
                "textLabel": instance.label,
                "type": type
            };

            if (e.target.checked) {
                currentFilter.element = e.target;
                this.push('_cachedFilters', currentFilter);
            } else {
                this._cachedFilters = this._cachedFilters.filter(function(filter) {
                    if (filter.category === currentFilter.category && filter.name === currentFilter.name)
                        return false;
                    return true;
                });
            };

            //all option stuff
            if(instance.additionalInfo){
                var $this = this;
                instance.additionalInfo.forEach(function(aItem){
                    if (aItem.key && aItem.key.toLowerCase() == 'isall' &&
                                            aItem.value && aItem.value.toLowerCase() == 'true'){
                        var chkBoxList = Polymer.dom($this.root).querySelectorAll('[data-category="' + category + '"][data-type="' + type + '"]:not([data-name="' + instance.name + '"])');
                        if(chkBoxList){
                            chkBoxList.forEach(function(chkBox){
                                if(e.currentTarget.checked){
                                    chkBox.checked = false;
                                    chkBox.disabled = true;
                                }
                                else{
                                    chkBox.checked = false;
                                    chkBox.disabled = false;
                                }
                            })
                        }

                    }
                })
            }
        }
    },

    _isRating: function(category) {
        return category.toLowerCase() === 'rating';
    },

    _isNotRating: function(category) {
        return category.toLowerCase() != 'rating';
    },

    /*
    Range filter stuff
     */
    _getMaxRange: function(items, index) {
        var range = items[index + 1];

        return range.value;
    },

    _getMinRange: function(items, index) {
        var range = items[index];

        return range.value;
    },

    _isEven: function(index) {
        return index % 2 === 0;
    },

    _rangeChanged: function(e) {

        var instance = e.model.item;
        var target = e.currentTarget;
        var category = target.getAttribute("data-category");
        var group = target.getAttribute("data-group");
        var subCategory = target.label;
        var elementIndex = target.getAttribute('data-index');
        var type = target.getAttribute("data-type");
        this.$.applyfilters.disabled = false;
        this._cachedFilters = this._cachedFilters.filter(function(data) {
            var cIndex = data.element ? data.element.getAttribute('data-index') : undefined;
            return data.category != category || elementIndex !== cIndex;
        });

        var currentFilter = {
            "category": category,
            "group": group,
            "subgroup": subCategory,
            "name": "Range",
            "min": target.from,
            "max": target.to,
            "label": category,
            "type": type
        };

        currentFilter.element = e.target;
        this.push('_cachedFilters', currentFilter);

    },

    /*
    Date range filter stuff
     */
    _dateChanged: function(e) {

        if (!e.model.dateRange)
            return;

        var instance = e.model.dateRange;
        var target = e.currentTarget;

        if (target.id === "startDate") {
            this._startDateDateChanged();
        } else {
            this._endDateDateChanged();
        }

        var category = target.getAttribute("data-category");
        var group = target.getAttribute("data-group");
        var subCategory = target.label;
        var elementIndex = target.getAttribute('data-index');
        var type = target.getAttribute("data-type");
        var name = target.getAttribute("name");

        this.$.applyfilters.disabled = false;

        this._cachedFilters = this._cachedFilters.filter(function(data) {
            var cIndex = data.element ? data.element.getAttribute('data-index') : undefined;
            return data.category != category || elementIndex !== cIndex;
        });

        var currentFilter = {
            "category": category,
            "group": group,
            "subgroup": subCategory,
            "name": name,
            "min": target.from,
            "max": target.to,
            "label": category,
            "type": type
        };

        currentFilter.element = e.target;
        this.push('_cachedFilters', currentFilter);

    },

    _startDateDateChanged: function() {
        if (this.startDate != '') {
            this.$$("#endDate").picker.set('min', new Date(this.startDate));
        } else {
            this.$$("#startDate").picker.set('max', false);
            this.$$("#endDate").picker.set('min', false);
        }
    },

    _endDateDateChanged: function() {
        if (this.endDate != '') {
            this.$$("#startDate").picker.set('max', new Date(this.endDate));
        } else {
            this.$$("#startDate").picker.set('max', false);
        }
    }


})
</script>
