<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../t-input/t-input.html" />
<link rel="import" href="../t-button/t-button.html" />
<link rel="import" href="../t-range/t-range.html" />
<link rel="import" href="../t-starrating/t-starrating.html" />
<link rel="import" href="../iron-collapse/iron-collapse.html" />
<link rel="import" href="../t-checkbox/t-checkbox.html" />
<link rel="import" href="../t-calendar/t-calendar.html" />
<link rel="import" href="../t-header/t-header.html" />
<link rel="import" href="../paper-item/paper-item.html" />
<link rel="import" href="../iron-icon/iron-icon.html" />
<link rel="import" href="../iron-list/iron-list.html" />
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<!--
    `<t-filter>` is a polymer component that generates a playground for interacting with components.
    
    If parent view explicitly asks to show price or count with option filter by setting either of `show-{{group}}-count` or `show-{{group}}-price`,
    component handles this to show respective value along with `option` filter 

    <div class="demo-canvas">
    </div>

    <t-filter metadata-source="metadata url" property-source="property url" component="component name">

        
        <div class="component">
            'component template'
        </div>
    </t-filter>     
-->
<dom-module id="t-customfilter">
    <script type="text/javascript">
    Polymer({
        is: 't-customfilter',
        properties: {
            filterData: {
                type: Object,
                value: function() {
                    return {};
                }
            }
        },

        ready: function() {
            this.fire("t-customfilter-ready", {
                'filter': this.filterData
            });
        },

        // attached: function() {
        //     this.fire("t-customfilter-attached", {
        //         'filter': this.filterData
        //     });
        // },


    });
    </script>
</dom-module>
<dom-module id="t-filter">
    <style include="iron-flex-alignment"></style>
    <style include="iron-positioning"></style>
    <style include="iron-flex"></style>
    <style>
    /*
    :root {
        --checkbox-unchecked-color: var(-grey-two, #eeeeee);
        --checkbox-unchecked-ink-color: var(-grey-two, #eeeeee);
    }*/
    
    :host {
        font-size: var(--font-12, 12px);
        font-family: var(--primary-font-family);
        cursor: pointer;
        display: block;
        color: var(--primary-text-color, #333333);
        -webkit-tap-highlight-color: transparent;
    }
    
    .scrollsection .item{
        padding: 10px;
        margin: 10px 0;
        min-width: 100%;
        box-sizing: border-box;
        @apply(--layout-flex);
    }
    
    .category {
        padding: 2px 0;
        font-size: var(--filter-label-font-size, 16px);
        border-bottom: 1px solid;
        border-color: var(--input-border-color, #eeeeee);
        
        @apply(--filter-category);
    }
    
    .category iron-icon {
        will-change: transform;
        transition: 0.3s ease transform;
    }
    
    .category.closed iron-icon {
        transform: rotate(180deg);
    }
    
    .filter-block {
        padding: 0 0 10px;
    }
    
    .filter-block > .layout {
        margin-top: 20px;
    }
    
    t-checkbox {
        width: 100%;
    }
    
    t-range {
        margin: 0 15px;
    }
    
    .range-block {
        padding: 10px 0;
    }
    
    .font-12 {
        font-size: var(--font-12, 12px);
    }
    
    t-starrating::content paper-icon-button {
        padding: 0;
        width: 16px;
        height: 16px;
        position: static;
        margin: 0;
        line-height: normal;
    }
    
    t-starrating::content .t-starrating-wrapper > span {
        width: auto;
        vertical-align: super;
        font-size: 0;
    }

    .scrollsection {
       /* 
        @apply(--layout-horizontal);
        @apply(--layout-start);
        @apply(--layout-wrap);*/
        position: relative;
    }
    
    .link {
        color: var(--link-color, #0098ff);
        padding: 10px;
    }
    
    .display-value {
        margin-right: 5px;
    }
    
    .devider {
        width: 1px;
        height: 20px;
        margin: 0px 5px 0 10px;
        background: var(--grey-three, #bbbbbb);
    }
    
    ::content #checkboxLabel {
        padding-left: 20px;
        line-height: 18px;
        color: var(--primary-text-color, #333333);
    }
    
    t-range {
        font-size: var(--font-14, 14px);
    }
    t-range::content .label-form,
    ::content .display-value,
    .secondary-text {
        color: var(--grey-three, #bbbbbb);
        font-size: var(--font-14, 14px);
    }
/*    .rowSeparator{
        display: none;
    }*/
    @media(min-width: 768px){
    /*    .rowSeparator{
            width: 100%;
            height: 1px;
            background: var(--input-border-color, rgba(0,0,0,0.54));
            margin: 10px 0;
            display: block;
        }*/
        .scrollsection .item{
            min-width: 150px;
            border-right: 1px solid var(--input-border-color, rgba(0,0,0,0.54));
            max-height: 220px;
            overflow: hidden;
            @apply(--layout-vertical);
            @apply(--filter-block-item);
        }
        .scrollsection .item.lastItem{
            border-right: 0;
        }
        .scrollsection .category {
            pointer-events: none;
            border-bottom: 0;
            display: block;
        }
        .item iron-collapse{
            overflow: auto;
        }
        .category iron-icon{
            display: none;
        }
        #controller .filterApply {
            position: absolute;
            bottom: 20px;
            right: 0;
        }
        .scrollsection .item.calendarItem{
            min-width: 310px;
        }
        t-calendar{
            max-width: 120px;
        }
    .row-item{
        @apply(--layout-horizontal);
        border-bottom: 1px solid var(--input-border-color, red);
        overflow-x: auto;
        width: 100%;
        @apply(--filter-row);
    }
    .row-item.lastItem {
        width: calc(100% - 130px);
    }

    }
    </style>
    <template>
        <div id="controller">
            <div class="flex scrollsection">
                <template is="dom-repeat" items="[[_data]]" as="row">
                    <div class$="{{_isLastItem(_data,index)}} row-item">
                        <template is="dom-repeat" items="[[row]]" as="key">
                            <template is="dom-if" if="{{_isTypeMatching(key,'Options')}}">
                                <div class$="{{_isLastItem(row,index)}} layout item">
                                    <div class="category layout horizontal center noclick-header" data-category$="[[key.category]]" data-category$="[[key.category]]" on-click="_toggle">
                                        <div class="flex label-form">[[key.label]]</div>
                                        <iron-icon class="secondary-text" icon="icons:expand-less"></iron-icon>
                                    </div>
                                    <iron-collapse opened="[[!hideFilters]]" id="[[key.category]]" data-label$="[[key.label]]">
                                        <div class="filter-block">
                                            <template is="dom-if" if="[[_isNotRating(key.category)]]">
                                                <template is="dom-repeat" items="[[key.items]]" as="item">
                                                    <div class="layout horizontal" hidden$="[[_hideFilterByCount(item.additionalInfo)]]">
                                                        <div class="layout horizontal flex  justified style-scope t-component-panel">
                                                            <t-checkbox data-label$="{{key.label}}" data-category$="[[key.category]]" data-type$="[[key.type]]" on-checked-change="_checkChanged" data-name$="[[item.name]]">
                                                                <div class="layout horizontal center justified">
                                                                    <div>[[item.label]]</div>
                                                                    <span class="display-value">[[_getDisplayValue(item)]]</span>
                                                                </div>
                                                            </t-checkbox>
                                                        </div>
                                                    </div>
                                                </template>
                                            </template>
                                            <template is="dom-if" if="[[_isRating(key.category)]]" as="key">
                                                <template is="dom-repeat" items="[[key.items]]" as="item">
                                                    <div class="layout  justified style-scope t-component-panel">
                                                        <t-checkbox data-type$="[[key.type]]" data-label$="{{key.label}}" data-category$="[[key.category]]" name$="[[item.name]]" value$="[[item.value]]" on-checked-change="_checkChanged">
                                                            <div class="layout horizontal center font-12 justified">
                                                                <t-starrating disabled stars="5" rate="[[item.name]]"></t-starrating>
                                                                <div class="display-value">
                                                                    [[_getDisplayValue(item)]]
                                                                </div>
                                                            </div>
                                                        </t-checkbox>
                                                    </div>
                                                </template>
                                            </template>
                                        </div>
                                    </iron-collapse>
                                </div>
                            </template>
                            <template is="dom-if" if="{{_isTypeMatching(key,'Range')}}">
                                <div class$="{{_isLastItem(row,index)}} layout item">
                                    <div class="category layout horizontal center noclick-header" data-category$="[[key.category]]" on-click="_toggle">
                                        <div class="flex label-form">[[_getDisplayLabel(key)]]</div>
                                        <iron-icon class="secondary-text" icon="icons:expand-less"></iron-icon>
                                    </div>
                                    <iron-collapse opened="[[!hideFilters]]" id="Iron-collapse1">
                                        <div class="filter-block">
                                            <template is="dom-repeat" items="[[key.items]]" as="range" index-as="i">
                                                <template is="dom-if" if="[[_isEven(i)]]">
                                                    <div class="range-block">
                                                        <t-range label="[[range.label]]" data-index$="[[i]]" data-category$="[[key.category]]" data-type$="[[key.type]]" data-group$="[[range.group]]" min="[[_getMinRange(key.items, i)]]" max="[[_getMaxRange(key.items, i)]]" on-range-change="_rangeChanged" margin="1"></t-range>
                                                    </div>
                                                </template>
                                            </template>
                                        </div>
                                    </iron-collapse>
                                </div>
                            </template>
                            <template is="dom-if" if="{{_isTypeMatching(key,'DateRange')}}">
                                <div class$="{{_isLastItem(row,index)}} layout item calendarItem">
                                    <div class="category layout horizontal center noclick-header" data-category$="[[key.category]]" on-click="_toggle">
                                        <div class="flex label-form">[[_getDisplayLabel(key)]]</div>
                                        <iron-icon class="secondary-text" icon="icons:expand-less"></iron-icon>
                                    </div>
                                    <iron-collapse opened="[[!hideFilters]]" id="Iron-collapse2">
                                        <div class="filter-block">
                                            <template is="dom-repeat" items="[[key.items]]" as="dateRange" index-as="i">
                                                <template is="dom-if" if="[[_isEven(i)]]">
                                                    <div class="layout horizontal">
                                                        <t-calendar no-label-float class="flex margin-horizontal" data-index="0" data-category$="[[key.category]]" data-type$="[[key.type]]" data-group$="[[dateRange.group]]" label="Start Date" name="StartDate" id="startDate" selected-date="{{startDate}}" format="mm/dd/yyyy" on-selected-date-changed="_dateChanged" min="[[minStartDate]]">
                                                        </t-calendar>
                                                        &nbsp; &nbsp; &nbsp;
                                                        <t-calendar no-label-float class="flex" data-index="1" data-category$="[[key.category]]" data-type$="[[key.type]]" data-group$="[[dateRange.group]]" label="End Date" name="EndDate" id="endDate" selected-date="{{endDate}}" format="mm/dd/yyyy" on-selected-date-changed="_dateChanged" min="[[minEndDate]]">
                                                        </t-calendar>
                                                    </div>
                                                </template>
                                            </template>
                                        </div>
                                    </iron-collapse>
                                </div>
                            </template>
                            <template is="dom-if" if="{{!_isFilterTypeSupported(key)}}">
                                <div class$="{{_isLastItem(row,index)}} layout item">
                                    <div class="category layout horizontal center noclick-header" data-category$="[[key.category]]" on-click="_toggle">
                                        <div class="flex label-form">[[_getDisplayLabel(key)]]</div>
                                        <iron-icon class="secondary-text" icon="icons:expand-less"></iron-icon>
                                    </div>
                                    <iron-collapse opened="[[!hideFilters]]" id="Iron-collapse2">
                                        <div class="filter-block">
                                            <t-customfilter filter-data="{{key}}" on-t-customfilter-ready="_runCustomHashReady"></t-customfilter>
                                        </div>
                                    </iron-collapse>
                                </div>
                            </template>
                        </template>
                    </div>
                    <!--
                    <template is="dom-if" if="[[_addRow(index)]]">
                        <div class="rowSeparator"></div>
                    </template> -->
                </template>
                <!--- filter apply and cancel button -->
                <div class="layout horizontal center filterApply">
                    <t-button id="applyfilters" label="Apply" class="primary" on-click="_applyFilters" disabled="true"></t-button>
                    <a class="link" on-click="_resetFilters">[[resetButtonLabel]]</a>
                </div>
            </div>
        </div>
    </template>
</dom-module>
<script>
/*
Sample custom filter api
 */
var api = {
    category: '',
    type: '',
    element: null,

    addHtml: function(customFilterElem, filterData, onChangeCallback) {

    },

    resetElement: function(customFilterElem) {

    },

    getDisplayLabel: function(filterData) {

    },

    getAppliedFilter: function(customFilterElem, filterData, lastChange) {

    }
};

Polymer({

    is: 't-filter',

    properties: {
        //pass the reset button Label
        resetButtonLabel:{
            type: String,
            value: 'CLEAR'
        },

        data: {
            type: Array,
            value: function() {
                return [];
            }
        },

        includeFilters: {
            type: Array,
            value: function() {
                return [];
            }
        },

        appliedFilters: {
            type: Array,
            value: function() {
                return [];
            },
            readOnly: true,
        },

        hide: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
        },

        customFiltersHash: {
            type: Array,
            value: function() {
                return [];
            }
        },

        _cachedFilters: {
            type: Array,
            value: function() {
                return [];
            }
        },


        _data: {
            type: Array,
            value: function() {
                return [];
            }
        },


        /*
        TODO: Remove all below ones and expose extension for all in-built filters
         */
        _currency: {
            type: String,
            value: 'USD'
        },

        _disableFilters: {
            type: Boolean,
            value: false
        },

        hideFilters: {
            type: Boolean,
            value: false
        },

        minStartDate: {
            type: Boolean,
            value: false
        },

        minEndDate: {
            type: Boolean,
            value: false
        }

    },

    observers: [
        '_filtersAddedOrRemoved(data.splices)'
    ],

    ready: function() {
        //debugger;
    },

    attached: function() {
        //debugger;
    },

    /*
    Filter core
     */
    _filtersAddedOrRemoved: function(e) {
        if (this.data) {
            var dataToApply = this._applyInclusions(this.data);

            if (dataToApply && dataToApply.length && Array.isArray(dataToApply[0]) == false) {
                dataToApply = [dataToApply];
            }

            this._data = dataToApply;

            var $this = this;
            this.async(function() {
                $this._data.forEach(function(row) {
                    row.forEach(function(fItem) {
                        if (['options', 'rating'].indexOf(fItem.type.toLowerCase()) != -1) {
                            if (fItem.items) {
                                var isAllPresent = false;
                                fItem.items.forEach(function(oItem) {
                                    if (oItem.additionalInfo && isAllPresent == false) {
                                        oItem.additionalInfo.forEach(function(aItem) {
                                            if (aItem.key && aItem.key.toLowerCase() == 'isall' &&
                                                aItem.value && aItem.value.toLowerCase() == 'true') {

                                                var cbk = Polymer.dom($this.root).querySelector('[data-name="' + oItem.name + '"][data-category="' + fItem.category + '"][data-type="' + fItem.type + '"]');
                                                if (cbk) {
                                                    cbk.checked = true; //TODO: Should check API response whether to select element or not
                                                    isAllPresent = true;
                                                }
                                            }
                                        })
                                    }
                                })
                            }

                        }
                    });
                });
            }, 350); //delay to render html
        }
    },

    _applyInclusions: function(filters) {
        var component = this;
        if (!this.includeFilters || this.includeFilters.length == 0)
            return filters;

        var inclusiveFilters = filters.filter(function(group) {
            if (component.includeFilters.indexOf(group.category) >= 0)
                return true;
            return false;
        });
        return inclusiveFilters;
    },
    _isLastItem: function(r,i){
        return r.length === i + 1 ? 'lastItem':'';
    },
    _isTypeMatching: function(key, type) {
        if (key.type === type && key.items.length > 0)
            return true;
        return false;
    },

    _isFilterTypeSupported: function(key) {
        if (key.type && ['options', 'range', 'daterange'].indexOf(key.type.toLowerCase()) != -1) {
            return true;
        }
        return false;
    },

    _toggle: function(event) {
        event.currentTarget.classList.toggle('closed');
        var parentElement = event.currentTarget.parentElement,
            element = parentElement.querySelector('iron-collapse');
        if (element !== null)
            element.toggle();
        event.stopPropagation();
        return false;
    },

    _resetElement: function(element, name, category) {
        var cHash = this._getCustomHash(category, name);
        if (cHash) {
            cHash.resetElement(cHash.filterElem);
        } else {
            switch (element.tagName.toLowerCase()) {
                case 't-checkbox':
                    element.checked = false;
                    break;
                case 't-range':
                    if (name.toLowerCase() == 'range') {
                        element.from = element.min.toString();
                        element.to = element.max.toString();
                    }

                    break;
                case 't-input':
                    element.value = '';
                    break;
                case 't-calendar':
                    element._clear();
                    //patch because in app is not removing the input value
                    element.querySelector('input').value = '';
                    break;
            }
        }
    },

    _resetFilters: function() {
        var component = this;
        this._cachedFilters.forEach(function(cache) {
            component._resetElement(cache.element, cache.type, cache.category);
        });
        this._cachedFilters = this._cachedFilters.filter(function(filter, index) {
            return false;
        });
        setTimeout(function() {
            component._applyFilters();
        }, 0);
    },

    _getDisplayLabel: function(key) {
        var cHash = this._getCustomHash(key.category, key.type);
        if (cHash) {
            return cHash.getDisplayLabel(key);
        } else {
            if (key.items[0].additionalInfo && key.items[0].additionalInfo[0].value.toLowerCase() !== 'ticks') {
                if (this._currency) {
                    return key.label + ' (' + this._currency + ')';
                }
                return key.label + ' (' + key.items[0].additionalInfo[0].value + ')';
            }
            return key.label;
        }
    },

    _applyFilters: function(e) {
        if (e) {
            if (e.target.id == 'applyfilters' && e.target.disabled) {
                return;
            }
        }
        this.$.applyfilters.disabled = true;
        var component = this;
        var filters = [];
        this._cachedFilters.forEach(function(filter) {
            filters = filters.concat(component._getAppliedFilter(filter));
        });
        this._setAppliedFilters(filters);
        setTimeout(function() {
            component.fire('filter-change', {
                "filters": component.appliedFilters,
                "count": component._cachedFilters.length
            });
        }, 0);
    },

    _getAppliedFilter: function(filter) {
        var filters = [];
        switch (filter.type) {
            case 'Options':
                filters.push({
                    "category": filter.category,
                    "group": filter.group,
                    "name": filter.name,
                    "value": filter.value,
                    "label": filter.label,
                    "type": filter.type
                });
                break;
            case 'Range':
                filters.push({
                    "category": filter.category,
                    "group": filter.group,
                    "name": "Min",
                    "value": filter.min,
                    "label": filter.label,
                    "type": filter.type
                });
                filters.push({
                    "category": filter.category,
                    "group": filter.group,
                    "name": "Max",
                    "value": filter.max,
                    "label": filter.label,
                    "type": filter.type
                });
                break;
            case 'DateRange':
                filters.push({
                    "category": filter.category,
                    "group": filter.group,
                    "name": filter.name,
                    "value": filter.element.selectedDate,
                    "label": filter.label,
                    "type": filter.type
                });
                break;
            default:
                var cHash = this._getCustomHash(filter.category, filter.type);
                var lastChange = this._cachedFilters.find(function(data) {
                    return data.category == filter.category && data.type == filter.type;
                });
                if (cHash) {
                    var data = cHash.getAppliedFilter(cHash.filterElem, filter, lastChange);
                    if (data) {
                        if (Array.isArray(data)) {
                            filters = filters.concat(data)
                        } else {
                            filters.push(data);
                        }
                    }
                }
        }

        return filters;
    },

    _getCountValue: function(items) {
        if (!items || !items.length)
            return '';

        var count = '';
        items.forEach(function(data) {
            if (data.key && data.key == 'Count') {
                count = '(' + data.value + ')';
            }
        });

        return count;
    },

    /**
     * This method returns diplay value for a filter.
     * It might be either `count` in additional info or `price` in the item value with _currency.
     * If parent view explicitely asks to show price or count by setting either of `show-{{group}}-count` or `show-{{group}}-price`,
     * method shows that value.
     * @param  {[Object]} item {"group":"Price","name":"Min","label":"Minimum Price","displayValue":"$17.49","value":"17.49","selectedValue":null,"additionalInfo":[{"key":"Unit","value":"$"}]}
     * @return {String}
     */
    _getDisplayValue: function(item) {
        var showCountProp = 'show' + item.group + 'Count';
        var showPriceProp = 'show' + item.group + 'Price';
        if (!this[showPriceProp] && !this[showCountProp]) {
            if (parseFloat(item.value)) {
                return this._getMinValueWithCurrency(item);
            } else {
                return this._getCountValue(item.additionalInfo);
            }
        } else if (this[showPriceProp]) {
            return this._getMinValueWithCurrency(item);
        } else if (this[showCountProp]) {
            return this._getCountValue(item.additionalInfo);
        }
        return "";
    },

    _getMinValueWithCurrency: function(item) {
        if (this._currency) {
            item.value = parseFloat(Math.round(item.value * 100) / 100);
            return this._currency + ' ' + item.value;
        } else {
            return item.displayValue;
        }
    },

    _getCustomHash: function(category, type) {
        if (this.customFiltersHash && this.customFiltersHash.length && category && type) {
            var cFilter = this.customFiltersHash.find(function(data) {
                return data.category == category && data.type == type
            });
            return cFilter;
        }
    },

    _runCustomHashReady: function(e) {
        var component = this
        var cHash = this._getCustomHash(e.detail.filter.category, e.detail.filter.type);
        if (cHash) {
            cHash.filterElem = e.srcElement; //back field
            cHash.addHtml(e.srcElement, e.detail.filter, function(changeData) {

                component.$.applyfilters.disabled = false;

                component._cachedFilters = component._cachedFilters.filter(function(filter) {
                    if (filter.category === changeData.category && filter.name === changeData.name)
                        return false;
                    return true;
                });
                component._cachedFilters.push(changeData);
            });
        }
    },


    /*
    Option filter stuff
     */
    _hideFilterByCount: function(items) {
        if (!items || !items.length)
            return false;

        var hideFilter = false;
        items.forEach(function(data) {
            if (data.key && data.key == 'Count' && data.value == 0) {
                hideFilter = true;
            }
        });

        return hideFilter;
    },

    _checkChanged: function(e) {
        var instance = e.model.item;
        var target = e.currentTarget;
        var category = target.getAttribute("data-category");

        if (instance) {
            this.$.applyfilters.disabled = false;

            var label = e.currentTarget.getAttribute("data-label");
            var type = e.currentTarget.getAttribute("data-type");
            var currentFilter = {
                "category": category,
                "group": instance.group,
                "name": instance.name,
                "value": instance.value,
                "label": label,
                "textLabel": instance.label,
                "type": type
            };

            if (e.target.checked) {
                currentFilter.element = e.target;
                this.push('_cachedFilters', currentFilter);
            } else {
                this._cachedFilters = this._cachedFilters.filter(function(filter) {
                    if (filter.category === currentFilter.category && filter.name === currentFilter.name)
                        return false;
                    return true;
                });
            };

            //all option stuff
            if (instance.additionalInfo) {
                var $this = this;
                instance.additionalInfo.forEach(function(aItem) {
                    if (aItem.key && aItem.key.toLowerCase() == 'isall' &&
                        aItem.value && aItem.value.toLowerCase() == 'true') {
                        var chkBoxList = Polymer.dom($this.root).querySelectorAll('[data-category="' + category + '"][data-type="' + type + '"]:not([data-name="' + instance.name + '"])');
                        if (chkBoxList) {
                            chkBoxList.forEach(function(chkBox) {
                                if (e.currentTarget.checked) {
                                    chkBox.checked = false;
                                    chkBox.disabled = true;
                                } else {
                                    chkBox.checked = false;
                                    chkBox.disabled = false;
                                }
                            })
                        }

                    }
                })
            }
        }
    },

    _isRating: function(category) {
        return category.toLowerCase() === 'rating';
    },

    _isNotRating: function(category) {
        return category.toLowerCase() != 'rating';
    },

    /*
    Range filter stuff
     */
    _getMaxRange: function(items, index) {
        var range = items[index + 1];

        return range.value;
    },

    _getMinRange: function(items, index) {
        var range = items[index];

        return range.value;
    },

    _isEven: function(index) {
        return index % 2 === 0;
    },

    _rangeChanged: function(e) {

        var instance = e.model.item;
        var target = e.currentTarget;
        var category = target.getAttribute("data-category");
        var group = target.getAttribute("data-group");
        var subCategory = target.label;
        var elementIndex = target.getAttribute('data-index');
        var type = target.getAttribute("data-type");
        this.$.applyfilters.disabled = false;
        this._cachedFilters = this._cachedFilters.filter(function(data) {
            var cIndex = data.element ? data.element.getAttribute('data-index') : undefined;
            return data.category != category || elementIndex !== cIndex;
        });

        var currentFilter = {
            "category": category,
            "group": group,
            "subgroup": subCategory,
            "name": "Range",
            "min": target.from,
            "max": target.to,
            "label": category,
            "type": type
        };

        currentFilter.element = e.target;
        this.push('_cachedFilters', currentFilter);

    },

    /*
    Date range filter stuff
     */
    _dateChanged: function(e) {

        if (!e.model.dateRange)
            return;

        var instance = e.model.dateRange;
        var target = e.currentTarget;

        if (target.id === "startDate") {
            this._startDateDateChanged();
        } else {
            this._endDateDateChanged();
        }

        var category = target.getAttribute("data-category");
        var group = target.getAttribute("data-group");
        var subCategory = target.label;
        var elementIndex = target.getAttribute('data-index');
        var type = target.getAttribute("data-type");
        var name = target.getAttribute("name");

        this.$.applyfilters.disabled = false;

        this._cachedFilters = this._cachedFilters.filter(function(data) {
            var cIndex = data.element ? data.element.getAttribute('data-index') : undefined;
            return data.category != category || elementIndex !== cIndex;
        });

        var currentFilter = {
            "category": category,
            "group": group,
            "subgroup": subCategory,
            "name": name,
            "min": target.from,
            "max": target.to,
            "label": category,
            "type": type
        };

        currentFilter.element = e.target;
        this.push('_cachedFilters', currentFilter);

    },

    _startDateDateChanged: function() {
        if (this.startDate != '') {
            this.$$("#endDate").picker.set('min', new Date(this.startDate));
        } else {
            this.$$("#startDate").picker.set('max', false);
            this.$$("#endDate").picker.set('min', false);
        }
    },

    _endDateDateChanged: function() {
        if (this.endDate != '') {
            this.$$("#startDate").picker.set('max', new Date(this.endDate));
        } else {
            this.$$("#startDate").picker.set('max', false);
        }
    }


})
</script>
